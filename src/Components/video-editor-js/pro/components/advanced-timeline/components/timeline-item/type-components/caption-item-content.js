import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { LetterText, Type } from 'lucide-react';
import { TimelineItemLabel } from './timeline-item-label';
import useZoomStore from '../../../stores/use-zoom-store';
export const CaptionItemContent = ({ label, data, start, end, isHovering = false, // Default to false
currentFrame, fps = 30, }) => {
    const { zoomState } = useZoomStore();
    const zoomScale = zoomState.scale;
    // Calculate duration and frame information
    const durationInSeconds = end - start;
    // Use captions from data if available, otherwise fall back to simple text
    const captions = (data === null || data === void 0 ? void 0 : data.captions) || [];
    const totalDurationSeconds = durationInSeconds;
    // Determine if we should show the simple label or detailed word blocks
    const shouldShowLabel = zoomScale <= 1 && totalDurationSeconds > 20;
    if (shouldShowLabel || !captions.length) {
        // Simple label mode for zoomed out view or when no detailed caption data is available
        const totalWords = captions.reduce((sum, caption) => sum + caption.words.length, 0);
        const iconClassName = `w-3 h-3 ${(data === null || data === void 0 ? void 0 : data.isAutoGenerated) ? 'text-yellow-400' : 'text-white/80'}`;
        // If we have caption data, show enhanced label with word count
        if (captions.length > 0) {
            return (_jsx("div", { className: "flex items-center h-full w-full overflow-hidden px-2 transition-all duration-200 ease-out bg-caption-item", children: _jsx("div", { className: `flex items-center min-w-0 w-full overflow-hidden transition-all duration-200 ease-out ${isHovering ? 'ml-6' : 'ml-4'}`, children: _jsxs("div", { className: "flex items-center p-1 rounded-sm overflow-hidden bg-caption-overlay/90", children: [_jsx("div", { className: "shrink-0 mr-2 flex items-center overflow-hidden", children: _jsx(LetterText, { className: "w-4 h-4 shrink-0 text-caption-item-active-foreground" }) }), _jsx("div", { className: "min-w-0 overflow-hidden", children: _jsxs("div", { className: "truncate text-xs font-extralight whitespace-nowrap text-caption-item-active-foreground", children: ["CAPTIONS   (", totalWords, " words)"] }) })] }) }) }));
        }
        else {
            // Fall back to the original simple label
            return (_jsx(TimelineItemLabel, { icon: Type, label: label, defaultLabel: "CAPTION", iconClassName: iconClassName, isHovering: isHovering }));
        }
    }
    // Detailed mode - show individual words as blocks
    // Improved font size calculation with logarithmic scaling
    const getFontSize = () => {
        const minSize = 8;
        const maxSize = 11; // Reduced from 12
        // Use logarithmic scaling for smoother growth at higher zoom levels
        const scale = Math.log10(zoomScale + 1);
        const size = minSize + Math.min(scale * 2, 3) * ((maxSize - minSize) / 3);
        return `${Math.round(size)}px`;
    };
    // Calculate current time in milliseconds relative to this item's start
    // Convert current frame to time and subtract item start time to get relative position
    const currentTimeInSeconds = currentFrame ? currentFrame / fps : 0;
    const itemRelativeTimeInSeconds = currentTimeInSeconds - start;
    const currentMs = itemRelativeTimeInSeconds * 1000; // Convert to milliseconds
    return (_jsx("div", { className: "absolute inset-0 flex w-full h-full z-10 pointer-events-none bg-caption-item", children: captions === null || captions === void 0 ? void 0 : captions.map((caption, index) => {
            const captionWidth = ((caption.endMs - caption.startMs) /
                (durationInSeconds * 1000)) *
                100;
            return (_jsx("div", { className: "h-full flex items-center justify-start pointer-events-auto", style: {
                    width: `${captionWidth}%`,
                    left: `${(caption.startMs / (durationInSeconds * 1000)) * 100}%`,
                    position: "absolute",
                }, children: caption.words.map((word, wordIndex) => {
                    const wordWidth = ((word.endMs - word.startMs) /
                        (caption.endMs - caption.startMs)) *
                        100;
                    const isWordActive = currentMs >= word.startMs && currentMs < word.endMs;
                    return (_jsx("div", { className: `flex p-[3px] items-center justify-center mx-px rounded-[3px] transition-all duration-150 ${isWordActive ? "bg-caption-item-active " : "bg-caption-item-foreground"}`, style: {
                            width: `${wordWidth}%`,
                        }, children: _jsx("span", { className: `truncate ${isWordActive ? "text-white font-medium " : "text-white"}`, style: {
                                fontSize: getFontSize(),
                            }, children: word.word }) }, wordIndex));
                }) }, index));
        }) }));
};
